// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var DateFns = require("../../../shared/utils/DateFns.bs.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var ListUtils = require("../../../shared/utils/ListUtils.bs.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var CoursesCurriculum__Team = require("./CoursesCurriculum__Team.bs.js");
var CoursesCurriculum__Level = require("./CoursesCurriculum__Level.bs.js");
var CoursesCurriculum__Course = require("./CoursesCurriculum__Course.bs.js");
var CoursesCurriculum__Target = require("./CoursesCurriculum__Target.bs.js");
var CoursesCurriculum__TargetGroup = require("./CoursesCurriculum__TargetGroup.bs.js");
var CoursesCurriculum__LatestSubmission = require("./CoursesCurriculum__LatestSubmission.bs.js");

function isPast(date) {
  return Belt_Option.mapWithDefault(date, false, DateFns.isPast);
}

function makePending(targets) {
  return List.map((function (t) {
                return {
                        targetId: CoursesCurriculum__Target.id(t),
                        status: /* Pending */0
                      };
              }), targets);
}

function lockTargets(targets, reason) {
  return List.map((function (t) {
                return {
                        targetId: CoursesCurriculum__Target.id(t),
                        status: /* Locked */[reason]
                      };
              }), targets);
}

function allTargetsComplete(targetCache, targetIds) {
  return List.for_all((function (targetId) {
                var cachedTarget = List.find((function (ct) {
                        return ct.targetId === targetId;
                      }), targetCache);
                return cachedTarget.submissionStatus === /* SubmissionPassed */2;
              }), targetIds);
}

function compute(preview, team, course, levels, targetGroups, targets, submissions) {
  if (preview) {
    return makePending(targets);
  } else {
    var date = CoursesCurriculum__Course.endsAt(course);
    if (Belt_Option.mapWithDefault(date, false, DateFns.isPast)) {
      return lockTargets(targets, /* CourseLocked */0);
    } else {
      var date$1 = CoursesCurriculum__Team.accessEndsAt(team);
      if (Belt_Option.mapWithDefault(date$1, false, DateFns.isPast)) {
        return lockTargets(targets, /* AccessLocked */1);
      } else {
        var studentLevelNumber = CoursesCurriculum__Level.number(List.find((function (l) {
                    return CoursesCurriculum__Level.id(l) === CoursesCurriculum__Team.levelId(team);
                  }), levels));
        var targetsCache = List.map((function (target) {
                var targetId = CoursesCurriculum__Target.id(target);
                var targetGroup = List.find((function (tg) {
                        return CoursesCurriculum__TargetGroup.id(tg) === CoursesCurriculum__Target.targetGroupId(target);
                      }), targetGroups);
                var milestone = CoursesCurriculum__TargetGroup.milestone(targetGroup);
                var levelNumber = CoursesCurriculum__Level.number(List.find((function (l) {
                            return CoursesCurriculum__Level.id(l) === CoursesCurriculum__TargetGroup.levelId(targetGroup);
                          }), levels));
                var submission = ListUtils.findOpt((function (s) {
                        return CoursesCurriculum__LatestSubmission.targetId(s) === targetId;
                      }), submissions);
                var submissionStatus;
                if (submission !== undefined) {
                  var s = submission;
                  submissionStatus = CoursesCurriculum__LatestSubmission.hasPassed(s) ? /* SubmissionPassed */2 : (
                      CoursesCurriculum__LatestSubmission.hasBeenEvaluated(s) ? /* SubmissionFailed */3 : /* SubmissionPendingReview */1
                    );
                } else {
                  submissionStatus = /* SubmissionMissing */0;
                }
                return {
                        targetId: targetId,
                        targetReviewed: CoursesCurriculum__Target.reviewed(target),
                        levelNumber: levelNumber,
                        milestone: milestone,
                        submissionStatus: submissionStatus,
                        prerequisiteTargetIds: CoursesCurriculum__Target.prerequisiteTargetIds(target)
                      };
              }), targets);
        return List.map((function (ct) {
                      var match = ct.submissionStatus;
                      var status;
                      switch (match) {
                        case /* SubmissionMissing */0 :
                            status = ct.levelNumber > studentLevelNumber && ct.targetReviewed ? /* Locked */[/* LevelLocked */2] : (
                                allTargetsComplete(targetsCache, ct.prerequisiteTargetIds) ? /* Pending */0 : /* Locked */[/* PrerequisitesIncomplete */3]
                              );
                            break;
                        case /* SubmissionPendingReview */1 :
                            status = /* Submitted */1;
                            break;
                        case /* SubmissionPassed */2 :
                            status = /* Passed */2;
                            break;
                        case /* SubmissionFailed */3 :
                            status = /* Failed */3;
                            break;
                        
                      }
                      return {
                              targetId: ct.targetId,
                              status: status
                            };
                    }), targetsCache);
      }
    }
  }
}

function targetId(t) {
  return t.targetId;
}

function status(t) {
  return t.status;
}

function lockReasonToString(lr) {
  switch (lr) {
    case /* CourseLocked */0 :
        return "The course has ended and submissions are disabled for all targets!";
    case /* AccessLocked */1 :
        return "Your access to this course has ended.";
    case /* LevelLocked */2 :
        return "You must level up to complete this target.";
    case /* PrerequisitesIncomplete */3 :
        return "This target has pre-requisites that are incomplete.";
    
  }
}

function statusToString(t) {
  var match = t.status;
  if (typeof match === "number") {
    switch (match) {
      case /* Pending */0 :
          return "Pending";
      case /* Submitted */1 :
          return "Submitted";
      case /* Passed */2 :
          return "Passed";
      case /* Failed */3 :
          return "Failed";
      
    }
  } else {
    return "Locked";
  }
}

function canSubmit(resubmittable, t) {
  var match = t.status;
  if (resubmittable) {
    if (typeof match === "number" && match === 2) {
      return true;
    }
    
  } else if (typeof match === "number" && match === 2) {
    return false;
  }
  if (typeof match === "number") {
    return match !== 1;
  } else {
    return false;
  }
}

function currentLevelStatuses(progressionBehavior) {
  if (typeof progressionBehavior === "number" && progressionBehavior < 751362817) {
    return /* :: */[
            /* Passed */2,
            /* [] */0
          ];
  } else {
    return /* :: */[
            /* Submitted */1,
            /* :: */[
              /* Passed */2,
              /* [] */0
            ]
          ];
  }
}

function matchesStatuses(statuses, ts) {
  var matchedTargetStatuses = List.filter((function (t) {
            return List.mem(t.status, statuses);
          }))(ts);
  return Caml_obj.caml_equal(ts, matchedTargetStatuses);
}

var Course = /* alias */0;

var Team = /* alias */0;

var Target = /* alias */0;

var Level = /* alias */0;

var TargetGroup = /* alias */0;

var LatestSubmission = /* alias */0;

var minimumRequiredLevelStatuses = /* :: */[
  /* Passed */2,
  /* [] */0
];

exports.Course = Course;
exports.Team = Team;
exports.Target = Target;
exports.Level = Level;
exports.TargetGroup = TargetGroup;
exports.LatestSubmission = LatestSubmission;
exports.isPast = isPast;
exports.makePending = makePending;
exports.lockTargets = lockTargets;
exports.allTargetsComplete = allTargetsComplete;
exports.compute = compute;
exports.targetId = targetId;
exports.status = status;
exports.lockReasonToString = lockReasonToString;
exports.statusToString = statusToString;
exports.canSubmit = canSubmit;
exports.currentLevelStatuses = currentLevelStatuses;
exports.minimumRequiredLevelStatuses = minimumRequiredLevelStatuses;
exports.matchesStatuses = matchesStatuses;
/* DateFns Not a pure module */
