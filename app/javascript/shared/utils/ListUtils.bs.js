// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var UnsafeFindFailed = Caml_exceptions.create("ListUtils.UnsafeFindFailed");

function isEmpty(l) {
  if (l) {
    return false;
  } else {
    return true;
  }
}

function isNotEmpty(l) {
  return !isEmpty(l);
}

function findOpt(p, l) {
  try {
    return Caml_option.some(List.find(p, l));
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return ;
    } else {
      throw exn;
    }
  }
}

function unsafeFind(p, message, l) {
  try {
    return List.find(p, l);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      Rollbar.error(message);
      throw [
            UnsafeFindFailed,
            message
          ];
    } else {
      throw exn;
    }
  }
}

function distinct(l) {
  var _l = l;
  var _d = /* [] */0;
  while(true) {
    var d = _d;
    var l$1 = _l;
    if (l$1) {
      var tail = l$1[1];
      var head = l$1[0];
      if (List.exists((function(head){
            return function (u) {
              return Caml_obj.caml_equal(u, head);
            }
            }(head)), d)) {
        _l = tail;
        continue ;
      } else {
        _d = /* :: */[
          head,
          d
        ];
        _l = tail;
        continue ;
      }
    } else {
      return d;
    }
  };
}

function swapDown(e, l) {
  var _prev = /* [] */0;
  var _l = l;
  var e$1 = e;
  while(true) {
    var l$1 = _l;
    var prev = _prev;
    if (l$1) {
      var tail = l$1[1];
      var head = l$1[0];
      if (tail && Caml_obj.caml_equal(head, e$1)) {
        return Pervasives.$at(prev, /* :: */[
                    tail[0],
                    /* :: */[
                      head,
                      tail[1]
                    ]
                  ]);
      }
      _l = tail;
      _prev = Pervasives.$at(prev, /* :: */[
            head,
            /* [] */0
          ]);
      continue ;
    } else {
      return prev;
    }
  };
}

function swapUp(e, l) {
  return List.rev(swapDown(e, List.rev(l)));
}

function swap(up, e, l) {
  if (up) {
    return swapUp(e, l);
  } else {
    return swapDown(e, l);
  }
}

exports.UnsafeFindFailed = UnsafeFindFailed;
exports.isEmpty = isEmpty;
exports.isNotEmpty = isNotEmpty;
exports.findOpt = findOpt;
exports.unsafeFind = unsafeFind;
exports.distinct = distinct;
exports.swapDown = swapDown;
exports.swapUp = swapUp;
exports.swap = swap;
/* No side effect */
