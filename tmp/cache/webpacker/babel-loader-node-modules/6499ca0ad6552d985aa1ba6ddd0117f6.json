{"ast":null,"code":"'use strict';\n\nvar $$Array = require(\"./array.js\");\n\nvar Curry = require(\"./curry.js\");\n\nvar Int32 = require(\"./int32.js\");\n\nvar Int64 = require(\"./int64.js\");\n\nvar Digest = require(\"./digest.js\");\n\nvar Caml_sys = require(\"./caml_sys.js\");\n\nvar Nativeint = require(\"./nativeint.js\");\n\nvar Caml_array = require(\"./caml_array.js\");\n\nvar Caml_int64 = require(\"./caml_int64.js\");\n\nvar Caml_string = require(\"./caml_string.js\");\n\nvar Caml_builtin_exceptions = require(\"./caml_builtin_exceptions.js\");\n\nfunction assign(st1, st2) {\n  $$Array.blit(st2.st, 0, st1.st, 0, 55);\n  st1.idx = st2.idx;\n  return (\n    /* () */\n    0\n  );\n}\n\nfunction full_init(s, seed) {\n  var combine = function combine(accu, x) {\n    return Digest.string(accu + String(x));\n  };\n\n  var extract = function extract(d) {\n    return ((Caml_string.get(d, 0) + (Caml_string.get(d, 1) << 8) | 0) + (Caml_string.get(d, 2) << 16) | 0) + (Caml_string.get(d, 3) << 24) | 0;\n  };\n\n  var seed$1 = seed.length === 0 ? [0] : seed;\n  var l = seed$1.length;\n\n  for (var i = 0; i <= 54; ++i) {\n    Caml_array.caml_array_set(s.st, i, i);\n  }\n\n  var accu = \"x\";\n\n  for (var i$1 = 0, i_finish = 54 + (55 > l ? 55 : l) | 0; i$1 <= i_finish; ++i$1) {\n    var j = i$1 % 55;\n    var k = i$1 % l;\n    accu = combine(accu, Caml_array.caml_array_get(seed$1, k));\n    Caml_array.caml_array_set(s.st, j, (Caml_array.caml_array_get(s.st, j) ^ extract(accu)) & 1073741823);\n  }\n\n  s.idx = 0;\n  return (\n    /* () */\n    0\n  );\n}\n\nfunction make(seed) {\n  var result = {\n    st: Caml_array.caml_make_vect(55, 0),\n    idx: 0\n  };\n  full_init(result, seed);\n  return result;\n}\n\nfunction make_self_init(param) {\n  return make(Caml_sys.caml_sys_random_seed(\n  /* () */\n  0));\n}\n\nfunction copy(s) {\n  var result = {\n    st: Caml_array.caml_make_vect(55, 0),\n    idx: 0\n  };\n  assign(result, s);\n  return result;\n}\n\nfunction bits(s) {\n  s.idx = (s.idx + 1 | 0) % 55;\n  var curval = Caml_array.caml_array_get(s.st, s.idx);\n  var newval = Caml_array.caml_array_get(s.st, (s.idx + 24 | 0) % 55) + (curval ^ curval >>> 25 & 31) | 0;\n  var newval30 = newval & 1073741823;\n  Caml_array.caml_array_set(s.st, s.idx, newval30);\n  return newval30;\n}\n\nfunction $$int(s, bound) {\n  if (bound > 1073741823 || bound <= 0) {\n    throw [Caml_builtin_exceptions.invalid_argument, \"Random.int\"];\n  }\n\n  var s$1 = s;\n  var n = bound;\n\n  while (true) {\n    var r = bits(s$1);\n    var v = r % n;\n\n    if ((r - v | 0) > ((1073741823 - n | 0) + 1 | 0)) {\n      continue;\n    } else {\n      return v;\n    }\n  }\n\n  ;\n}\n\nfunction int32(s, bound) {\n  if (bound <= 0) {\n    throw [Caml_builtin_exceptions.invalid_argument, \"Random.int32\"];\n  }\n\n  var s$1 = s;\n  var n = bound;\n\n  while (true) {\n    var b1 = bits(s$1);\n    var b2 = (bits(s$1) & 1) << 30;\n    var r = b1 | b2;\n    var v = r % n;\n\n    if ((r - v | 0) > ((Int32.max_int - n | 0) + 1 | 0)) {\n      continue;\n    } else {\n      return v;\n    }\n  }\n\n  ;\n}\n\nfunction int64(s, bound) {\n  if (Caml_int64.le(bound,\n  /* int64 */\n  [\n  /* hi */\n  0,\n  /* lo */\n  0])) {\n    throw [Caml_builtin_exceptions.invalid_argument, \"Random.int64\"];\n  }\n\n  var s$1 = s;\n  var n = bound;\n\n  while (true) {\n    var b1 = Caml_int64.of_int32(bits(s$1));\n    var b2 = Caml_int64.lsl_(Caml_int64.of_int32(bits(s$1)), 30);\n    var b3 = Caml_int64.lsl_(Caml_int64.of_int32(bits(s$1) & 7), 60);\n    var r = Caml_int64.or_(b1, Caml_int64.or_(b2, b3));\n    var v = Caml_int64.mod_(r, n);\n\n    if (Caml_int64.gt(Caml_int64.sub(r, v), Caml_int64.add(Caml_int64.sub(Int64.max_int, n),\n    /* int64 */\n    [\n    /* hi */\n    0,\n    /* lo */\n    1]))) {\n      continue;\n    } else {\n      return v;\n    }\n  }\n\n  ;\n}\n\nvar nativeint = Nativeint.size === 32 ? int32 : function (s, bound) {\n  return Caml_int64.to_int32(int64(s, Caml_int64.of_int32(bound)));\n};\n\nfunction rawfloat(s) {\n  var r1 = bits(s);\n  var r2 = bits(s);\n  return (r1 / 1073741824.0 + r2) / 1073741824.0;\n}\n\nfunction $$float(s, bound) {\n  return rawfloat(s) * bound;\n}\n\nfunction bool(s) {\n  return (bits(s) & 1) === 0;\n}\n\nvar $$default = {\n  st: [987910699, 495797812, 364182224, 414272206, 318284740, 990407751, 383018966, 270373319, 840823159, 24560019, 536292337, 512266505, 189156120, 730249596, 143776328, 51606627, 140166561, 366354223, 1003410265, 700563762, 981890670, 913149062, 526082594, 1021425055, 784300257, 667753350, 630144451, 949649812, 48546892, 415514493, 258888527, 511570777, 89983870, 283659902, 308386020, 242688715, 482270760, 865188196, 1027664170, 207196989, 193777847, 619708188, 671350186, 149669678, 257044018, 87658204, 558145612, 183450813, 28133145, 901332182, 710253903, 510646120, 652377910, 409934019, 801085050],\n  idx: 0\n};\n\nfunction bits$1(param) {\n  return bits($$default);\n}\n\nfunction $$int$1(bound) {\n  return $$int($$default, bound);\n}\n\nfunction int32$1(bound) {\n  return int32($$default, bound);\n}\n\nfunction nativeint$1(bound) {\n  return Curry._2(nativeint, $$default, bound);\n}\n\nfunction int64$1(bound) {\n  return int64($$default, bound);\n}\n\nfunction $$float$1(scale) {\n  return rawfloat($$default) * scale;\n}\n\nfunction bool$1(param) {\n  return bool($$default);\n}\n\nfunction full_init$1(seed) {\n  return full_init($$default, seed);\n}\n\nfunction init(seed) {\n  return full_init($$default, [seed]);\n}\n\nfunction self_init(param) {\n  return full_init$1(Caml_sys.caml_sys_random_seed(\n  /* () */\n  0));\n}\n\nfunction get_state(param) {\n  return copy($$default);\n}\n\nfunction set_state(s) {\n  return assign($$default, s);\n}\n\nvar State = {\n  make: make,\n  make_self_init: make_self_init,\n  copy: copy,\n  bits: bits,\n  $$int: $$int,\n  int32: int32,\n  nativeint: nativeint,\n  int64: int64,\n  $$float: $$float,\n  bool: bool\n};\nexports.init = init;\nexports.full_init = full_init$1;\nexports.self_init = self_init;\nexports.bits = bits$1;\nexports.$$int = $$int$1;\nexports.int32 = int32$1;\nexports.nativeint = nativeint$1;\nexports.int64 = int64$1;\nexports.$$float = $$float$1;\nexports.bool = bool$1;\nexports.State = State;\nexports.get_state = get_state;\nexports.set_state = set_state;\n/* No side effect */","map":null,"metadata":{},"sourceType":"module"}