{"ast":null,"code":"'use strict';\n\nvar DFA = require('./lib/dfa.js');\n\nmodule.exports = function multimd_table_plugin(md, options) {\n  // TODO be consistent with markdown-it method\n  options = options || {};\n\n  function scan_bound_indices(state, line) {\n    var start = state.bMarks[line],\n\n    /* no tShift to detect \\n */\n    max = state.skipSpacesBack(state.eMarks[line], start),\n        bounds = [],\n        pos,\n        escape = false,\n        code = false;\n    /* Scan for valid pipe character position */\n\n    for (pos = start; pos < max; pos++) {\n      switch (state.src.charCodeAt(pos)) {\n        case 0x5c\n        /* \\ */\n        :\n          escape = true;\n          break;\n\n        case 0x60\n        /* ` */\n        :\n          /* make \\` closes the code sequence, but not open it;\n             the reason is that `\\` is correct code block */\n          if (code || !escape) {\n            code = !code;\n          }\n\n          if (state.src.charCodeAt(pos - 1) === 0x60) {\n            code = false;\n          }\n\n          escape = false;\n          break;\n\n        case 0x7c\n        /* | */\n        :\n          if (!code && !escape) {\n            bounds.push(pos);\n          }\n\n          escape = false;\n          break;\n\n        default:\n          escape = false;\n          break;\n      }\n    }\n\n    if (bounds.length === 0) return bounds;\n    /* Pad in newline characters on last and this line */\n\n    if (bounds[0] > start) {\n      bounds.unshift(start - 1);\n    }\n\n    if (bounds[bounds.length - 1] < max - 1) {\n      bounds.push(max);\n    }\n\n    return bounds;\n  }\n\n  function table_caption(state, silent, line) {\n    var start = state.bMarks[line] + state.tShift[line],\n        max = state.eMarks[line],\n        capRE = /^\\[([^\\[\\]]+)\\](\\[([^\\[\\]]+)\\])?\\s*$/,\n        matches = state.src.slice(start, max).match(capRE),\n        meta = {};\n\n    if (!matches) {\n      return false;\n    }\n\n    if (silent) {\n      return true;\n    } // TODO eliminate capRE by simple checking\n\n\n    meta.text = matches[1];\n    meta.label = matches[2] || matches[1];\n    meta.label = meta.label.toLowerCase().replace(/\\W+/g, '');\n    return meta;\n  }\n\n  function table_row(state, silent, line) {\n    var bounds = scan_bound_indices(state, line),\n        meta = {},\n        start,\n        pos,\n        oldMax;\n\n    if (bounds.length < 2) {\n      return false;\n    }\n\n    if (silent) {\n      return true;\n    }\n\n    meta.bounds = bounds;\n    /* Multiline. Scan boundaries again since it's very complicated */\n\n    if (options.multiline) {\n      start = state.bMarks[line] + state.tShift[line];\n      pos = state.eMarks[line] - 1;\n      /* where backslash should be */\n\n      meta.multiline = state.src.charCodeAt(pos) === 0x5C\n      /* \\ */\n      ;\n\n      if (meta.multiline) {\n        oldMax = state.eMarks[line];\n        state.eMarks[line] = state.skipSpacesBack(pos, start);\n        meta.bounds = scan_bound_indices(state, line);\n        state.eMarks[line] = oldMax;\n      }\n    }\n\n    return meta;\n  }\n\n  function table_separator(state, silent, line) {\n    var bounds = scan_bound_indices(state, line),\n        meta = {\n      aligns: [],\n      wraps: []\n    },\n        sepRE = /^:?(-+|=+):?\\+?$/,\n        c,\n        text,\n        align;\n    /* Only separator needs to check indents */\n\n    if (state.sCount[line] - state.blkIndent >= 4) {\n      return false;\n    }\n\n    if (bounds.length === 0) {\n      return false;\n    }\n\n    for (c = 0; c < bounds.length - 1; c++) {\n      text = state.src.slice(bounds[c] + 1, bounds[c + 1]).trim();\n\n      if (!sepRE.test(text)) {\n        return false;\n      }\n\n      meta.wraps.push(text.charCodeAt(text.length - 1) === 0x2B\n      /* + */\n      );\n      align = (text.charCodeAt(0) === 0x3A\n      /* : */\n      ) << 4 | text.charCodeAt(text.length - 1 - meta.wraps[c]) === 0x3A;\n\n      switch (align) {\n        case 0x00:\n          meta.aligns.push('');\n          break;\n\n        case 0x01:\n          meta.aligns.push('right');\n          break;\n\n        case 0x10:\n          meta.aligns.push('left');\n          break;\n\n        case 0x11:\n          meta.aligns.push('center');\n          break;\n      }\n    }\n\n    if (silent) {\n      return true;\n    }\n\n    return meta;\n  }\n\n  function table_empty(state, silent, line) {\n    var start = state.bMarks[line] + state.tShift[line],\n        max = state.eMarks[line];\n    return start === max;\n  }\n\n  function table(state, startLine, endLine, silent) {\n    /* Regex pseudo code for table:\n     *     caption? header+ separator (data+ empty)* data+ caption?\n     *\n     * We use DFA to emulate this plugin. Types with lower precedence are\n     * set-minus from all the formers.  Noted that separator should have higher\n     * precedence than header or data.\n     *   |  state  | caption separator header data empty | --> lower precedence\n     *   | 0x10100 |    1        0       1     0     0   |\n     */\n    var tableDFA = new DFA(),\n        grp = 0x10,\n        mtr = -1,\n        token,\n        tableToken,\n        trToken,\n        colspan,\n        leftToken,\n        rowspan,\n        upTokens = [],\n        tableLines,\n        tgroupLines,\n        tag,\n        text,\n        range,\n        r,\n        c,\n        b;\n\n    if (startLine + 2 > endLine) {\n      return false;\n    }\n    /**\n     * First pass: validate and collect info into table token. IR is stored in\n     * markdown-it `token.meta` to be pushed later. table/tr open tokens are\n     * generated here.\n     */\n\n\n    tableToken = new state.Token('table_open', 'table', 1);\n    tableToken.meta = {\n      sep: null,\n      cap: null,\n      tr: []\n    };\n    tableDFA.set_highest_alphabet(0x10000);\n    tableDFA.set_initial_state(0x10100);\n    tableDFA.set_accept_states([0x10010, 0x10011, 0x00000]);\n    tableDFA.set_match_alphabets({\n      0x10000: table_caption.bind(this, state, true),\n      0x01000: table_separator.bind(this, state, true),\n      0x00100: table_row.bind(this, state, true),\n      0x00010: table_row.bind(this, state, true),\n      0x00001: table_empty.bind(this, state, true)\n    });\n    tableDFA.set_transitions({\n      0x10100: {\n        0x10000: 0x00100,\n        0x00100: 0x01100\n      },\n      0x00100: {\n        0x00100: 0x01100\n      },\n      0x01100: {\n        0x01000: 0x10010,\n        0x00100: 0x01100\n      },\n      0x10010: {\n        0x10000: 0x00000,\n        0x00010: 0x10011\n      },\n      0x10011: {\n        0x10000: 0x00000,\n        0x00010: 0x10011,\n        0x00001: 0x10010\n      }\n    });\n\n    if (options.headerless) {\n      tableDFA.set_initial_state(0x11100);\n      tableDFA.update_transition(0x11100, {\n        0x10000: 0x01100,\n        0x01000: 0x10010,\n        0x00100: 0x01100\n      });\n      trToken = new state.Token('table_fake_header_row', 'tr', 1);\n      trToken.meta = Object(); // avoid trToken.meta.grp throws exception\n    }\n    /* Don't mix up DFA `_state` and markdown-it `state` */\n\n\n    tableDFA.set_actions(function (_line, _state, _type) {\n      switch (_type) {\n        case 0x10000:\n          if (tableToken.meta.cap) {\n            break;\n          }\n\n          tableToken.meta.cap = table_caption(state, false, _line);\n          tableToken.meta.cap.map = [_line, _line + 1];\n          tableToken.meta.cap.first = _line === startLine;\n          break;\n\n        case 0x01000:\n          tableToken.meta.sep = table_separator(state, false, _line);\n          tableToken.meta.sep.map = [_line, _line + 1];\n          trToken.meta.grp |= 0x01; // previously assigned at case 0x00110\n\n          grp = 0x10;\n          break;\n\n        case 0x00100:\n        case 0x00010:\n          trToken = new state.Token('table_row_open', 'tr', 1);\n          trToken.map = [_line, _line + 1];\n          trToken.meta = table_row(state, false, _line);\n          trToken.meta.type = _type;\n          trToken.meta.grp = grp;\n          grp = 0x00;\n          tableToken.meta.tr.push(trToken);\n          /* Multiline. Merge trTokens as an entire multiline trToken */\n\n          if (options.multiline) {\n            if (trToken.meta.multiline && mtr < 0) {\n              /* Start line of multiline row. mark this trToken */\n              mtr = tableToken.meta.tr.length - 1;\n            } else if (!trToken.meta.multiline && mtr >= 0) {\n              /* End line of multiline row. merge forward until the marked trToken */\n              token = tableToken.meta.tr[mtr];\n              token.meta.mbounds = tableToken.meta.tr.slice(mtr).map(function (tk) {\n                return tk.meta.bounds;\n              });\n              token.map[1] = trToken.map[1];\n              tableToken.meta.tr = tableToken.meta.tr.slice(0, mtr + 1);\n              mtr = -1;\n            }\n          }\n\n          break;\n\n        case 0x00001:\n          trToken.meta.grp |= 0x01;\n          grp = 0x10;\n          break;\n      }\n    });\n\n    if (tableDFA.execute(startLine, endLine) === false) {\n      return false;\n    } // if (!tableToken.meta.sep) { return false; } // always evaluated true\n\n\n    if (!tableToken.meta.tr.length) {\n      return false;\n    } // false under headerless corner case\n\n\n    if (silent) {\n      return true;\n    }\n    /* Last data row cannot be detected. not stored to trToken outside? */\n\n\n    tableToken.meta.tr[tableToken.meta.tr.length - 1].meta.grp |= 0x01;\n    /**\n     * Second pass: actually push the tokens into `state.tokens`.\n     * thead/tbody/th/td open tokens and all closed tokens are generated here;\n     * thead/tbody are generally called tgroup; td/th are generally called tcol.\n     */\n\n    tableToken.map = tableLines = [startLine, 0];\n    tableToken.block = true;\n    tableToken.level = state.level++;\n    state.tokens.push(tableToken);\n\n    if (tableToken.meta.cap) {\n      token = state.push('caption_open', 'caption', 1);\n      token.map = tableToken.meta.cap.map;\n      token.attrs = [['id', tableToken.meta.cap.label]];\n      token = state.push('inline', '', 0);\n      token.content = tableToken.meta.cap.text;\n      token.map = tableToken.meta.cap.map;\n      token.children = [];\n      token = state.push('caption_close', 'caption', -1);\n    }\n\n    for (r = 0; r < tableToken.meta.tr.length; r++) {\n      leftToken = new state.Token('table_fake_tcol_open', '', 1);\n      /* Push in thead/tbody and tr open tokens */\n\n      trToken = tableToken.meta.tr[r]; // console.log(trToken.meta); // for test\n\n      if (trToken.meta.grp & 0x10) {\n        tag = trToken.meta.type === 0x00100 ? 'thead' : 'tbody';\n        token = state.push('table_group_open', tag, 1);\n        token.map = tgroupLines = [trToken.map[0], 0]; // array ref\n\n        upTokens = [];\n      }\n\n      trToken.block = true;\n      trToken.level = state.level++;\n      state.tokens.push(trToken);\n      /* Push in th/td tokens */\n\n      for (c = 0; c < trToken.meta.bounds.length - 1; c++) {\n        range = [trToken.meta.bounds[c] + 1, trToken.meta.bounds[c + 1]];\n        text = state.src.slice.apply(state.src, range);\n\n        if (text === '') {\n          colspan = leftToken.attrGet('colspan');\n          leftToken.attrSet('colspan', colspan === null ? 2 : colspan + 1);\n          continue;\n        }\n\n        if (options.rowspan && upTokens[c] && text.trim() === '^^') {\n          rowspan = upTokens[c].attrGet('rowspan');\n          upTokens[c].attrSet('rowspan', rowspan === null ? 2 : rowspan + 1);\n          continue;\n        }\n\n        tag = trToken.meta.type === 0x00100 ? 'th' : 'td';\n        token = state.push('table_column_open', tag, 1);\n        token.map = trToken.map;\n        token.attrs = [];\n\n        if (tableToken.meta.sep.aligns[c]) {\n          token.attrs.push(['style', 'text-align:' + tableToken.meta.sep.aligns[c]]);\n        }\n\n        if (tableToken.meta.sep.wraps[c]) {\n          token.attrs.push(['class', 'extend']);\n        }\n\n        leftToken = upTokens[c] = token;\n        /* Multiline. Join the text and feed into markdown-it blockParser. */\n\n        if (options.multiline && trToken.meta.multiline && trToken.meta.mbounds) {\n          text = [text.trimRight()];\n\n          for (b = 1; b < trToken.meta.mbounds.length; b++) {\n            /* Line with N bounds has cells indexed from 0 to N-2 */\n            if (c > trToken.meta.mbounds[b].length - 2) {\n              continue;\n            }\n\n            range = [trToken.meta.mbounds[b][c] + 1, trToken.meta.mbounds[b][c + 1]];\n            text.push(state.src.slice.apply(state.src, range).trimRight());\n          }\n\n          state.md.block.parse(text.join('\\n'), state.md, state.env, state.tokens);\n        } else {\n          token = state.push('inline', '', 0);\n          token.content = text.trim();\n          token.map = trToken.map;\n          token.children = [];\n        }\n\n        token = state.push('table_column_close', tag, -1);\n      }\n      /* Push in tr and thead/tbody closed tokens */\n\n\n      state.push('tr_close', 'tr', -1);\n\n      if (trToken.meta.grp & 0x01) {\n        tag = trToken.meta.type === 0x00100 ? 'thead' : 'tbody';\n        token = state.push('table_group_close', tag, -1);\n        tgroupLines[1] = trToken.map[1];\n      }\n    }\n\n    tableLines[1] = Math.max(tgroupLines[1], tableToken.meta.sep.map[1], tableToken.meta.cap ? tableToken.meta.cap.map[1] : -1);\n    token = state.push('table_close', 'table', -1);\n    state.line = tableLines[1];\n    return true;\n  }\n\n  md.block.ruler.at('table', table, {\n    alt: ['paragraph', 'reference']\n  });\n};\n/* vim: set ts=2 sw=2 et: */","map":null,"metadata":{},"sourceType":"module"}