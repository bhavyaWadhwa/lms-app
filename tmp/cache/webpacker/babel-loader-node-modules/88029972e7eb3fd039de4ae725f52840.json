{"ast":null,"code":"'use strict';\n\nvar Caml_int32 = require(\"./caml_int32.js\");\n\nvar Caml_utils = require(\"./caml_utils.js\");\n\nvar Caml_primitive = require(\"./caml_primitive.js\");\n\nvar Caml_builtin_exceptions = require(\"./caml_builtin_exceptions.js\");\n\nvar min_int =\n/* Int64 */\n[\n/* hi */\n-2147483648,\n/* lo */\n0];\nvar max_int =\n/* Int64 */\n[\n/* hi */\n2147483647,\n/* lo */\n1];\nvar one =\n/* Int64 */\n[\n/* hi */\n0,\n/* lo */\n1];\nvar zero =\n/* Int64 */\n[\n/* hi */\n0,\n/* lo */\n0];\nvar neg_one =\n/* Int64 */\n[\n/* hi */\n-1,\n/* lo */\n4294967295];\n\nfunction neg_signed(x) {\n  return (x & 2147483648) !== 0;\n}\n\nfunction succ(param) {\n  var x_lo = param[\n  /* lo */\n  1];\n  var x_hi = param[\n  /* hi */\n  0];\n  var lo = x_lo + 1 & 4294967295;\n  var hi = x_hi + (lo === 0 ? 1 : 0) & 4294967295;\n  return (\n    /* Int64 */\n    [\n    /* hi */\n    hi,\n    /* lo */\n    lo >>> 0]\n  );\n}\n\nfunction neg(param) {\n  var other_lo = (param[\n  /* lo */\n  1] ^ -1) + 1 & 4294967295;\n  var hi = (param[\n  /* hi */\n  0] ^ -1) + (other_lo === 0 ? 1 : 0) & 4294967295;\n  return (\n    /* Int64 */\n    [\n    /* hi */\n    hi,\n    /* lo */\n    other_lo >>> 0]\n  );\n}\n\nfunction add_aux(param, y_lo, y_hi) {\n  var x_lo = param[\n  /* lo */\n  1];\n  var lo = x_lo + y_lo & 4294967295;\n  var overflow = neg_signed(x_lo) && (neg_signed(y_lo) || !neg_signed(lo)) || neg_signed(y_lo) && !neg_signed(lo) ? 1 : 0;\n  var hi = param[\n  /* hi */\n  0] + y_hi + overflow & 4294967295;\n  return (\n    /* Int64 */\n    [\n    /* hi */\n    hi,\n    /* lo */\n    lo >>> 0]\n  );\n}\n\nfunction add_lo(self, lo) {\n  return add_aux(self, lo >>> 0, 0);\n}\n\nfunction add(self, param) {\n  return add_aux(self, param[\n  /* lo */\n  1], param[\n  /* hi */\n  0]);\n}\n\nfunction eq(param, param$1) {\n  if (param[\n  /* hi */\n  0] === param$1[\n  /* hi */\n  0]) {\n    return param[\n    /* lo */\n    1] === param$1[\n    /* lo */\n    1];\n  } else {\n    return false;\n  }\n}\n\nfunction equal_null(x, y) {\n  if (y !== null) {\n    return eq(x, y);\n  } else {\n    return false;\n  }\n}\n\nfunction equal_undefined(x, y) {\n  if (y !== undefined) {\n    return eq(x, y);\n  } else {\n    return false;\n  }\n}\n\nfunction equal_nullable(x, y) {\n  if (y == null) {\n    return false;\n  } else {\n    return eq(x, y);\n  }\n}\n\nfunction sub_aux(x, lo, hi) {\n  var neg_lo = ((lo ^ -1) + 1 & 4294967295) >>> 0;\n  var neg_hi = (hi ^ -1) + (neg_lo === 0 ? 1 : 0) & 4294967295;\n  return add_aux(x, neg_lo, neg_hi);\n}\n\nfunction sub(self, param) {\n  return sub_aux(self, param[\n  /* lo */\n  1], param[\n  /* hi */\n  0]);\n}\n\nfunction lsl_(x, numBits) {\n  if (numBits === 0) {\n    return x;\n  } else {\n    var lo = x[\n    /* lo */\n    1];\n\n    if (numBits >= 32) {\n      return (\n        /* Int64 */\n        [\n        /* hi */\n        lo << (numBits - 32 | 0),\n        /* lo */\n        0]\n      );\n    } else {\n      var hi = lo >>> (32 - numBits | 0) | x[\n      /* hi */\n      0] << numBits;\n      return (\n        /* Int64 */\n        [\n        /* hi */\n        hi,\n        /* lo */\n        lo << numBits >>> 0]\n      );\n    }\n  }\n}\n\nfunction lsr_(x, numBits) {\n  if (numBits === 0) {\n    return x;\n  } else {\n    var hi = x[\n    /* hi */\n    0];\n    var offset = numBits - 32 | 0;\n\n    if (offset === 0) {\n      return (\n        /* Int64 */\n        [\n        /* hi */\n        0,\n        /* lo */\n        hi >>> 0]\n      );\n    } else if (offset > 0) {\n      var lo = hi >>> offset;\n      return (\n        /* Int64 */\n        [\n        /* hi */\n        0,\n        /* lo */\n        lo >>> 0]\n      );\n    } else {\n      var hi$1 = hi >>> numBits;\n      var lo$1 = hi << (-offset | 0) | x[\n      /* lo */\n      1] >>> numBits;\n      return (\n        /* Int64 */\n        [\n        /* hi */\n        hi$1,\n        /* lo */\n        lo$1 >>> 0]\n      );\n    }\n  }\n}\n\nfunction asr_(x, numBits) {\n  if (numBits === 0) {\n    return x;\n  } else {\n    var hi = x[\n    /* hi */\n    0];\n\n    if (numBits < 32) {\n      var hi$1 = hi >> numBits;\n      var lo = hi << (32 - numBits | 0) | x[\n      /* lo */\n      1] >>> numBits;\n      return (\n        /* Int64 */\n        [\n        /* hi */\n        hi$1,\n        /* lo */\n        lo >>> 0]\n      );\n    } else {\n      var lo$1 = hi >> (numBits - 32 | 0);\n      return (\n        /* Int64 */\n        [\n        /* hi */\n        hi >= 0 ? 0 : -1,\n        /* lo */\n        lo$1 >>> 0]\n      );\n    }\n  }\n}\n\nfunction is_zero(param) {\n  if (param[\n  /* hi */\n  0] !== 0 || param[\n  /* lo */\n  1] !== 0) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction mul(_this, _other) {\n  while (true) {\n    var other = _other;\n    var $$this = _this;\n    var lo;\n    var exit = 0;\n    var exit$1 = 0;\n\n    if ($$this[\n    /* hi */\n    0] !== 0 || $$this[\n    /* lo */\n    1] !== 0) {\n      exit$1 = 3;\n    } else {\n      return zero;\n    }\n\n    if (exit$1 === 3) {\n      if (other[\n      /* hi */\n      0] !== 0 || other[\n      /* lo */\n      1] !== 0) {\n        exit = 2;\n      } else {\n        return zero;\n      }\n    }\n\n    if (exit === 2) {\n      var this_hi = $$this[\n      /* hi */\n      0];\n      var exit$2 = 0;\n\n      if (this_hi !== -2147483648 || $$this[\n      /* lo */\n      1] !== 0) {\n        exit$2 = 3;\n      } else {\n        lo = other[\n        /* lo */\n        1];\n      }\n\n      if (exit$2 === 3) {\n        var other_hi = other[\n        /* hi */\n        0];\n        var lo$1 = $$this[\n        /* lo */\n        1];\n        var exit$3 = 0;\n\n        if (other_hi !== -2147483648 || other[\n        /* lo */\n        1] !== 0) {\n          exit$3 = 4;\n        } else {\n          lo = lo$1;\n        }\n\n        if (exit$3 === 4) {\n          var other_lo = other[\n          /* lo */\n          1];\n\n          if (this_hi < 0) {\n            if (other_hi < 0) {\n              _other = neg(other);\n              _this = neg($$this);\n              continue;\n            } else {\n              return neg(mul(neg($$this), other));\n            }\n          } else if (other_hi < 0) {\n            return neg(mul($$this, neg(other)));\n          } else {\n            var a48 = this_hi >>> 16;\n            var a32 = this_hi & 65535;\n            var a16 = lo$1 >>> 16;\n            var a00 = lo$1 & 65535;\n            var b48 = other_hi >>> 16;\n            var b32 = other_hi & 65535;\n            var b16 = other_lo >>> 16;\n            var b00 = other_lo & 65535;\n            var c48 = 0;\n            var c32 = 0;\n            var c16 = 0;\n            var c00 = a00 * b00;\n            c16 = (c00 >>> 16) + a16 * b00;\n            c32 = c16 >>> 16;\n            c16 = (c16 & 65535) + a00 * b16;\n            c32 = c32 + (c16 >>> 16) + a32 * b00;\n            c48 = c32 >>> 16;\n            c32 = (c32 & 65535) + a16 * b16;\n            c48 = c48 + (c32 >>> 16);\n            c32 = (c32 & 65535) + a00 * b32;\n            c48 = c48 + (c32 >>> 16);\n            c32 = c32 & 65535;\n            c48 = c48 + (a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48) & 65535;\n            var hi = c32 | c48 << 16;\n            var lo$2 = c00 & 65535 | (c16 & 65535) << 16;\n            return (\n              /* Int64 */\n              [\n              /* hi */\n              hi,\n              /* lo */\n              lo$2 >>> 0]\n            );\n          }\n        }\n      }\n    }\n\n    if ((lo & 1) === 0) {\n      return zero;\n    } else {\n      return min_int;\n    }\n  }\n\n  ;\n}\n\nfunction swap(param) {\n  var hi = Caml_int32.caml_int32_bswap(param[\n  /* lo */\n  1]);\n  var lo = Caml_int32.caml_int32_bswap(param[\n  /* hi */\n  0]);\n  return (\n    /* Int64 */\n    [\n    /* hi */\n    hi,\n    /* lo */\n    lo >>> 0]\n  );\n}\n\nfunction xor(param, param$1) {\n  return (\n    /* Int64 */\n    [\n    /* hi */\n    param[\n    /* hi */\n    0] ^ param$1[\n    /* hi */\n    0],\n    /* lo */\n    (param[\n    /* lo */\n    1] ^ param$1[\n    /* lo */\n    1]) >>> 0]\n  );\n}\n\nfunction or_(param, param$1) {\n  return (\n    /* Int64 */\n    [\n    /* hi */\n    param[\n    /* hi */\n    0] | param$1[\n    /* hi */\n    0],\n    /* lo */\n    (param[\n    /* lo */\n    1] | param$1[\n    /* lo */\n    1]) >>> 0]\n  );\n}\n\nfunction and_(param, param$1) {\n  return (\n    /* Int64 */\n    [\n    /* hi */\n    param[\n    /* hi */\n    0] & param$1[\n    /* hi */\n    0],\n    /* lo */\n    (param[\n    /* lo */\n    1] & param$1[\n    /* lo */\n    1]) >>> 0]\n  );\n}\n\nfunction ge(param, param$1) {\n  var other_hi = param$1[\n  /* hi */\n  0];\n  var hi = param[\n  /* hi */\n  0];\n\n  if (hi > other_hi) {\n    return true;\n  } else if (hi < other_hi) {\n    return false;\n  } else {\n    return param[\n    /* lo */\n    1] >= param$1[\n    /* lo */\n    1];\n  }\n}\n\nfunction neq(x, y) {\n  return !eq(x, y);\n}\n\nfunction lt(x, y) {\n  return !ge(x, y);\n}\n\nfunction gt(param, param$1) {\n  if (param[\n  /* hi */\n  0] > param$1[\n  /* hi */\n  0]) {\n    return true;\n  } else if (param[\n  /* hi */\n  0] < param$1[\n  /* hi */\n  0]) {\n    return false;\n  } else {\n    return param[\n    /* lo */\n    1] > param$1[\n    /* lo */\n    1];\n  }\n}\n\nfunction le(x, y) {\n  return !gt(x, y);\n}\n\nfunction min(x, y) {\n  if (ge(x, y)) {\n    return y;\n  } else {\n    return x;\n  }\n}\n\nfunction max(x, y) {\n  if (gt(x, y)) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction to_float(param) {\n  return param[\n  /* hi */\n  0] * 0x100000000 + param[\n  /* lo */\n  1];\n}\n\nfunction of_float(x) {\n  if (isNaN(x) || !isFinite(x)) {\n    return zero;\n  } else if (x <= -9.22337203685477581e+18) {\n    return min_int;\n  } else if (x + 1 >= 9.22337203685477581e+18) {\n    return max_int;\n  } else if (x < 0) {\n    return neg(of_float(-x));\n  } else {\n    var hi = x / 4294967296 | 0;\n    var lo = x % 4294967296 | 0;\n    return (\n      /* Int64 */\n      [\n      /* hi */\n      hi,\n      /* lo */\n      lo >>> 0]\n    );\n  }\n}\n\nfunction isSafeInteger(param) {\n  var hi = param[\n  /* hi */\n  0];\n  var top11Bits = hi >> 21;\n\n  if (top11Bits === 0) {\n    return true;\n  } else if (top11Bits === -1) {\n    return !(param[\n    /* lo */\n    1] === 0 && hi === (4292870144 | 0));\n  } else {\n    return false;\n  }\n}\n\nfunction to_string(self) {\n  if (isSafeInteger(self)) {\n    return String(to_float(self));\n  } else if (self[\n  /* hi */\n  0] < 0) {\n    if (eq(self, min_int)) {\n      return \"-9223372036854775808\";\n    } else {\n      return \"-\" + to_string(neg(self));\n    }\n  } else {\n    var approx_div1 = of_float(Math.floor(to_float(self) / 10));\n    var lo = approx_div1[\n    /* lo */\n    1];\n    var hi = approx_div1[\n    /* hi */\n    0];\n    var match = sub_aux(sub_aux(self, lo << 3, lo >>> 29 | hi << 3), lo << 1, lo >>> 31 | hi << 1);\n    var rem_lo = match[\n    /* lo */\n    1];\n    var rem_hi = match[\n    /* hi */\n    0];\n\n    if (rem_lo === 0 && rem_hi === 0) {\n      return to_string(approx_div1) + \"0\";\n    } else if (rem_hi < 0) {\n      var rem_lo$1 = ((rem_lo ^ -1) + 1 & 4294967295) >>> 0;\n      var delta = Math.ceil(rem_lo$1 / 10);\n      var remainder = 10 * delta - rem_lo$1;\n      return to_string(sub_aux(approx_div1, delta | 0, 0)) + String(remainder | 0);\n    } else {\n      var rem_lo$2 = rem_lo;\n      var delta$1 = Math.floor(rem_lo$2 / 10);\n      var remainder$1 = rem_lo$2 - 10 * delta$1;\n      return to_string(add_lo(approx_div1, delta$1 | 0)) + String(remainder$1 | 0);\n    }\n  }\n}\n\nfunction div(_self, _other) {\n  while (true) {\n    var other = _other;\n    var self = _self;\n    var exit = 0;\n    var exit$1 = 0;\n\n    if (other[\n    /* hi */\n    0] !== 0 || other[\n    /* lo */\n    1] !== 0) {\n      exit$1 = 3;\n    } else {\n      throw Caml_builtin_exceptions.division_by_zero;\n    }\n\n    if (exit$1 === 3) {\n      var match = self[\n      /* hi */\n      0];\n\n      if (match !== -2147483648) {\n        if (match !== 0 || self[\n        /* lo */\n        1] !== 0) {\n          exit = 2;\n        } else {\n          return zero;\n        }\n      } else if (self[\n      /* lo */\n      1] !== 0) {\n        exit = 2;\n      } else if (eq(other, one) || eq(other, neg_one)) {\n        return self;\n      } else if (eq(other, min_int)) {\n        return one;\n      } else {\n        var half_this = asr_(self, 1);\n        var approx = lsl_(div(half_this, other), 1);\n        var exit$2 = 0;\n\n        if (approx[\n        /* hi */\n        0] !== 0 || approx[\n        /* lo */\n        1] !== 0) {\n          exit$2 = 4;\n        } else if (other[\n        /* hi */\n        0] < 0) {\n          return one;\n        } else {\n          return neg(one);\n        }\n\n        if (exit$2 === 4) {\n          var rem = sub(self, mul(other, approx));\n          return add(approx, div(rem, other));\n        }\n      }\n    }\n\n    if (exit === 2 && other[\n    /* hi */\n    0] === -2147483648 && other[\n    /* lo */\n    1] === 0) {\n      return zero;\n    }\n\n    var other_hi = other[\n    /* hi */\n    0];\n\n    if (self[\n    /* hi */\n    0] < 0) {\n      if (other_hi < 0) {\n        _other = neg(other);\n        _self = neg(self);\n        continue;\n      } else {\n        return neg(div(neg(self), other));\n      }\n    } else if (other_hi < 0) {\n      return neg(div(self, neg(other)));\n    } else {\n      var res = zero;\n      var rem$1 = self;\n\n      while (ge(rem$1, other)) {\n        var approx$1 = Caml_primitive.caml_float_max(1, Math.floor(to_float(rem$1) / to_float(other)));\n        var log2 = Math.ceil(Math.log(approx$1) / Math.LN2);\n        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n        var approxRes = of_float(approx$1);\n        var approxRem = mul(approxRes, other);\n\n        while (approxRem[\n        /* hi */\n        0] < 0 || gt(approxRem, rem$1)) {\n          approx$1 = approx$1 - delta;\n          approxRes = of_float(approx$1);\n          approxRem = mul(approxRes, other);\n        }\n\n        ;\n\n        if (is_zero(approxRes)) {\n          approxRes = one;\n        }\n\n        res = add(res, approxRes);\n        rem$1 = sub(rem$1, approxRem);\n      }\n\n      ;\n      return res;\n    }\n  }\n\n  ;\n}\n\nfunction mod_(self, other) {\n  return sub(self, mul(div(self, other), other));\n}\n\nfunction div_mod(self, other) {\n  var quotient = div(self, other);\n  return (\n    /* tuple */\n    [quotient, sub(self, mul(quotient, other))]\n  );\n}\n\nfunction compare(param, param$1) {\n  var v = Caml_primitive.caml_nativeint_compare(param[\n  /* hi */\n  0], param$1[\n  /* hi */\n  0]);\n\n  if (v === 0) {\n    return Caml_primitive.caml_nativeint_compare(param[\n    /* lo */\n    1], param$1[\n    /* lo */\n    1]);\n  } else {\n    return v;\n  }\n}\n\nfunction of_int32(lo) {\n  return (\n    /* Int64 */\n    [\n    /* hi */\n    lo < 0 ? -1 : 0,\n    /* lo */\n    lo >>> 0]\n  );\n}\n\nfunction to_int32(param) {\n  return param[\n  /* lo */\n  1] | 0;\n}\n\nfunction to_hex(x) {\n  var x_lo = x[\n  /* lo */\n  1];\n  var x_hi = x[\n  /* hi */\n  0];\n\n  var aux = function aux(v) {\n    return (v >>> 0).toString(16);\n  };\n\n  if (x_hi === 0 && x_lo === 0) {\n    return \"0\";\n  }\n\n  if (x_lo !== 0) {\n    if (x_hi !== 0) {\n      var lo = aux(x_lo);\n      var pad = 8 - lo.length | 0;\n\n      if (pad <= 0) {\n        return aux(x_hi) + lo;\n      } else {\n        return aux(x_hi) + (Caml_utils.repeat(pad, \"0\") + lo);\n      }\n    } else {\n      return aux(x_lo);\n    }\n  } else {\n    return aux(x_hi) + \"00000000\";\n  }\n}\n\nfunction discard_sign(x) {\n  return (\n    /* Int64 */\n    [\n    /* hi */\n    2147483647 & x[\n    /* hi */\n    0],\n    /* lo */\n    x[\n    /* lo */\n    1]]\n  );\n}\n\nfunction float_of_bits(param) {\n  return function (lo, hi) {\n    return new Float64Array(new Int32Array([lo, hi]).buffer)[0];\n  }(param[\n  /* lo */\n  1], param[\n  /* hi */\n  0]);\n}\n\nfunction bits_of_float(x) {\n  var buf = function (x) {\n    return new Int32Array(new Float64Array([x]).buffer);\n  }(x);\n\n  return (\n    /* Int64 */\n    [\n    /* hi */\n    buf[1],\n    /* lo */\n    buf[0] >>> 0]\n  );\n}\n\nexports.succ = succ;\nexports.min_int = min_int;\nexports.max_int = max_int;\nexports.one = one;\nexports.zero = zero;\nexports.of_int32 = of_int32;\nexports.to_int32 = to_int32;\nexports.add = add;\nexports.neg = neg;\nexports.sub = sub;\nexports.lsl_ = lsl_;\nexports.lsr_ = lsr_;\nexports.asr_ = asr_;\nexports.is_zero = is_zero;\nexports.mul = mul;\nexports.xor = xor;\nexports.or_ = or_;\nexports.and_ = and_;\nexports.swap = swap;\nexports.ge = ge;\nexports.eq = eq;\nexports.neq = neq;\nexports.lt = lt;\nexports.gt = gt;\nexports.le = le;\nexports.equal_null = equal_null;\nexports.equal_undefined = equal_undefined;\nexports.equal_nullable = equal_nullable;\nexports.min = min;\nexports.max = max;\nexports.to_float = to_float;\nexports.of_float = of_float;\nexports.div = div;\nexports.mod_ = mod_;\nexports.compare = compare;\nexports.float_of_bits = float_of_bits;\nexports.bits_of_float = bits_of_float;\nexports.div_mod = div_mod;\nexports.to_hex = to_hex;\nexports.discard_sign = discard_sign;\nexports.to_string = to_string;\n/* Caml_int32 Not a pure module */","map":null,"metadata":{},"sourceType":"module"}